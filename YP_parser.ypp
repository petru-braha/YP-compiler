/* comments:
 * YP_parser.ypp - bottom-up parser, LARL(1) grammar
 * (c) authors - Braha Petru Bogdan - <petrubraha@gmail.com>
 *             - Meraru Ioan Lucian - <https://github.com/Zamdacmalfal>
 * run command example: ./YP exs/success/declaration/class/declaration.txt
 * run command example: ./YP exs/fail/declaration/class/field\ 0.txt
 
 *!* compilation should never throw exceptions *!*
 *!* all data is encoded as string *!*
 
 * states:
 ** declaration
 ** definition
 ** call
 * order of state presentation:
 ** class
 ** variable
 ** function
 ** object
 * statements

 * class == type
 * the number of started scopes == symbols.size(); 
 * exception: symbol table insertions won't provide error messages

 * how error checks are written: 
    for each terminal/non-terminal we perform checks
    we start with the first one and continue consecutively

 * yes parameters - no  array
 * yes parameters - yes array
 * no  parameters - no  array
 * no  parameters - yes array
 */

%{
  #include <stdio.h>
  #include <cstring>
  #include <cmath>
  #include <string>
  #include <vector>
  #include "YP_utility.hpp"

  extern int yylex();
  void yyerror(const char * s);

  extern FILE* yyin;
  extern char* yytext;
  extern int yylineno;
  size_t count_error;
  std::vector<symbol_table> symbols;
  #define LAST_SCOPE symbols.size() - 1

  char* cls_last_name = nullptr;
%}

%left '&' '|'
%left "==" "!=" "<=" "<" ">=" ">"
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'

%right '='
%right '^'

%union {
  char* information;
  unsigned char character;
    
  bool bool_number;
  long long intg_number;
  double real_number;
}

%token SCOPE_BEGIN SCOPE_END
%token MASTER TYPEOF PRINTF

%token RSV_CLSS ACS_PRIV ACS_PUBL ACS_FILD

%token<information> SMT_NAME RSV_TYPE RSV_ARRY DEF_ARRY
%token<intg_number> LIT_INTG LIT_CHAR LIT_BOOL
%token<real_number> LIT_FLOT
%token<information> LIT_STRG
%type<information> LIT_CALL

%token<character> OPR_ASSIGN OPRU OPR0 OPR1 OPR2
%token<information> OPR_RELTON

%type<information> expression
%type<information> term
%type<information> fact
%type<information> powr

%token ACT_BREK ACT_CONT ACT_RTRN
%token SEQ_IFIF SEQ_ELSE SEQ_WHLE SEQ_FOOR

%start starting_symbol

%%
/*!------------------------------------------------
/*!------------------------------------------------
/*! declarations */

starting_symbol : { /** initialize the compiler */
                    function_data f_data0("int"),
                      f_data1("string");
                    
                    symbol_table s;
                    s.insert("print", &f_data0);
                    s.insert("type", &f_data1);
                    
                    symbols.emplace_back();
                    symbols[0] = s;
                  }
                  global_declaration
                  { /** check for errors at the end */
                    if(0 == count_error)
                      printf("the program was compiled correctly.\n");
                    else
                      printf("the program has %zu errors.\n", count_error);
                  };

global_declaration: MASTER
                    SCOPE_BEGIN
                    statement_list
                  | cls_decl global_declaration
                  | cls_defn global_declaration
                  | var_decl global_declaration
                  | var_defn global_declaration
                  | fct_decl global_declaration
                  | fct_defn global_declaration
                  | obj_decl global_declaration
                  | obj_defn global_declaration
                  ;

cls_decl: RSV_CLSS SMT_NAME ';'{
            if(size_t(-1) != scope_search($2))
              yyerror("identifier already defined");
            free($2);
          }
        ;

cls_defn: RSV_CLSS SMT_NAME SCOPE_BEGIN {
            if(size_t(-1) != scope_search($2))
              yyerror("identifier already defined");
            else
            {
              cls_last_name = strdup($2);
              type_insert($2, symbol_table($2));
            }

            free($2);
          }
          cls_fild arr_fild { 
            free(cls_last_name);
            cls_last_name = nullptr; 
          }
        | RSV_CLSS SMT_NAME SCOPE_BEGIN SCOPE_END {
          if(size_t(-1) != scope_search($2))
              yyerror("identifier already defined");
            else
              type_insert($2, symbol_table($2));
            
            free($2);
          }
        ;

arr_fild: cls_fild arr_fild
        | SCOPE_END
        ;

/* 20 rules for field
 * 4 rules for variable
 * 8 rules for function
 * 2 rules for constructor
 * 4 rules for object
 * 2 rules for access specifier
 */

cls_fild: /** 4v rules */ 
          RSV_TYPE SMT_NAME ';' {
            bool is_error = false, error_flag = false;

            if(error_flag |= is_error = type_exists($2);
              is_error)
              yyerror("type treated as an identifier");

            if(error_flag |= is_error =
              type_exists(cls_last_name)->get_data($2);
              is_error)
              yyerror("identifier already defined in class");
            
            // success
            if(false == error_flag)
            {
              variable_data v_data($1);
              type_exists(cls_last_name)->insert($2, &v_data);
            }

            free($1);
            free($2);
        }
        | RSV_ARRY SMT_NAME ';' {
            bool is_error = false, error_flag = false;

            if(error_flag |= is_error = type_exists($2);
              is_error)
              yyerror("type treated as an identifier");

            if(error_flag |= is_error =
              type_exists(cls_last_name)->get_data($2);
              is_error)
              yyerror("identifier already defined in class");
            
            // success
            if(false == error_flag)
            {
              /*todo array of */
              //variable_data v_data($1);
              //type_exists(cls_last_name)->insert($2, &v_data);
            }

            free($1);
            free($2);
        }
        | RSV_TYPE SMT_NAME OPR_ASSIGN expression ';' {
            bool is_error = false, error_flag = false;

            if(error_flag |= is_error = type_exists($2);
              is_error)
              yyerror("type treated as an identifier");

            if(error_flag |= is_error =
              type_exists(cls_last_name)->get_data($2);
              is_error)
              yyerror("identifier already defined in class");

            if(error_flag |= is_error =
              nullptr == $4 || type_of($4) != std::string($1);
              is_error)
              yyerror("incompatible types");
            
            // success
            if(false == error_flag)
            {
              variable_data v_data($1, $4);
              type_exists(cls_last_name)->insert($2, &v_data);
            }

            free($1);
            free($2);
            free($4);
        }
        | RSV_ARRY SMT_NAME OPR_ASSIGN expression ';' {
            bool is_error = false, error_flag = false;

            if(error_flag |= is_error = type_exists($2);
              is_error)
              yyerror("type treated as an identifier");

            if(error_flag |= is_error =
              type_exists(cls_last_name)->get_data($2);
              is_error)
              yyerror("identifier already defined in class");

            if(error_flag |= is_error =
              nullptr == $4 || type_of($4) != std::string($1);
              is_error)
              yyerror("incompatible types");
            
            // success
            if(false == error_flag)
            {
              variable_data v_data($1, $4);
              /*todo vector*/
              type_exists(cls_last_name)->insert($2, &v_data);
            }

            free($1);
            free($2);
            free($4);
        }
        
          /** 8f rules */
        | RSV_TYPE SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | RSV_ARRY SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | RSV_TYPE SMT_NAME '('')'
          SCOPE_BEGIN
          statement_list ';'
        | RSV_ARRY SMT_NAME '('')'
          SCOPE_BEGIN
          statement_list ';'
          
        | SMT_NAME SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | DEF_ARRY SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | SMT_NAME SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';'
        | DEF_ARRY SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';'

          /** 2c rules */
        | SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';' {
            if(std::string($1) != std::string(cls_last_name))
              yyerror("constructor should be labeled as class");
          }
        | SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
  
          /** 4o rules */
        | SMT_NAME SMT_NAME ';'
        | DEF_ARRY SMT_NAME ';'
        | SMT_NAME SMT_NAME OPR_ASSIGN '{' attribte obj_vals
        | DEF_ARRY SMT_NAME OPR_ASSIGN '{' attribte obj_vals
        
          /** 2a rules */
        | ACS_PRIV
        | ACS_PUBL
        ;

var_decl: RSV_TYPE SMT_NAME ';'
        | RSV_ARRY SMT_NAME ';'
        ;
var_defn: RSV_TYPE SMT_NAME OPR_ASSIGN expression ';'
        | RSV_ARRY SMT_NAME OPR_ASSIGN expression ';'
        ;

fct_decl: RSV_TYPE SMT_NAME '(' parametr arr_parm ';'
        | RSV_ARRY SMT_NAME '(' parametr arr_parm ';'
        | RSV_TYPE SMT_NAME '(' ')' ';'
        | RSV_ARRY SMT_NAME '(' ')' ';'
        | SMT_NAME SMT_NAME '(' parametr arr_parm ';'
        | DEF_ARRY SMT_NAME '(' parametr arr_parm ';'
        | SMT_NAME SMT_NAME '(' ')' ';'
        | DEF_ARRY SMT_NAME '(' ')' ';'
        ;
fct_defn: RSV_TYPE SMT_NAME '(' parametr arr_parm 
          SCOPE_BEGIN
          statement_list ';'
        | RSV_ARRY SMT_NAME '(' parametr arr_parm 
          SCOPE_BEGIN
          statement_list ';'
        | RSV_TYPE SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';'
        | RSV_ARRY SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';'
        | SMT_NAME SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | DEF_ARRY SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | SMT_NAME SMT_NAME '(' ')'
          SCOPE_BEGIN
        | DEF_ARRY SMT_NAME '(' ')'
          SCOPE_BEGIN
        ;
arr_parm: parametr arr_parm
        | ')'
        ;
parametr: ',' RSV_TYPE SMT_NAME
        | ',' RSV_ARRY SMT_NAME
        | ',' SMT_NAME SMT_NAME
        | ',' DEF_ARRY SMT_NAME
        ;

obj_decl: SMT_NAME SMT_NAME ';'
        | DEF_ARRY SMT_NAME ';'
        ;
obj_defn: SMT_NAME SMT_NAME OPR_ASSIGN '{' attribte obj_vals
        | DEF_ARRY SMT_NAME OPR_ASSIGN '{' attribte obj_vals
        ;
obj_vals: ',' attribte obj_vals
        | '}'
        ;
attribte: expression
        ;

LIT_CALL: LIT_INTG { $$ = nullptr; }
        | LIT_FLOT { $$ = nullptr; }
        | LIT_CHAR { $$ = nullptr; }
        | LIT_STRG { $$ = nullptr; }
        | LIT_BOOL { $$ = nullptr; }
        ;

/*!------------------------------------------------
/*!------------------------------------------------
/*! statements */

statement_list: SCOPE_END { symbols.pop_back(); }
              | local_declaration statement_list
              | expression ';' statement_list
              | assignment ';' statement_list
              | ACT_BREK ';' statement_list
              | ACT_CONT ';' statement_list
              | ACT_RTRN ';' statement_list
              | control statement_list
              ;

local_declaration : var_decl
                  | var_defn
                  | fct_decl
                  | fct_defn
                  | obj_decl
                  | obj_defn
                  ;

expression: term OPR0 expression { $$ = nullptr; }
          | term OPR0 OPRU expression { $$ = nullptr; }
          | term OPR_RELTON expression {              
              if(0 == strcmp($2, "=="))
                $$ = 0;
              else if(0 == strcmp($2, "!="))
                $$ = 0;
              else if(0 == strcmp($2, "<="))
                $$ = 0;
              else if(0 == strcmp($2, "<"))
                $$ = 0;
              else if(0 == strcmp($2, ">="))
                $$ = 0;
              else if(0 == strcmp($2, ">"))
                $$ = 0;
            }
          | term { $$ = nullptr; }
          ;
term: term OPR1 fact { $$ = nullptr; }
    | fact { $$ = $1; }
    ;
fact: fact OPR2 powr { $$ = nullptr; }
    | powr { $$ = $1; }
    ;
powr: '(' expression ')' { $$ = $2; }
    | LIT_CALL { $$ = $1; }
    | SMT_NAME { $$ = 0; }
    | SMT_NAME ACS_FILD SMT_NAME { $$ = 0; }
    | SMT_NAME '[' LIT_INTG ']' { $$ = 0; }
    | SMT_NAME '[' SMT_NAME ']' { $$ = 0; }
    | PRINTF '(' expression ')' { $$ = 0; printf("%s", $3); fflush(stdout); }
    | TYPEOF '(' expression ')' {
        std::string s = type_of($3);
        $$ = strdup(s.c_str());
      }
    | fct_call {$$ = nullptr; }
    ;

fct_call: SMT_NAME '(' expression arr_argm
        | SMT_NAME '('')'
        ;
arr_argm: ',' expression arr_argm
        | ')'
        ;

control : SEQ_IFIF '(' expression ')' '{' statement_list '}'
        | SEQ_IFIF '(' expression ')' '{' statement_list '}' SEQ_ELSE '{' statement_list '}'
        | SEQ_WHLE '(' expression ')' '{' statement_list '}'
        | SEQ_FOOR '(' expression ';' expression ';' expression ')' '{' statement_list '}'

assignment: SMT_NAME OPR_ASSIGN assig_term
          ;
assig_term: expression
          | assignment
          ;
%%

/*!------------------------------------------------
/*!------------------------------------------------
/*! C++ functions */

void yyerror(const char * s){
  count_error++;
  printf("error - line %d: %s.\n", yylineno, s);
  if(0 == strcmp(s, "syntax error"))
    printf("the program has %zu errors.\n", count_error);
}

int main(int argc, char** argv)
{
  if(argc != 2)
  {
    yyerror("wrong number of arguments");
    return EXIT_FAILURE;
  }

  FILE* ptr = fopen(argv[1], "r");
  if(nullptr == ptr)
  {
    yyerror("invalid file");
    return EXIT_FAILURE;
  }

  yyin = ptr;
  yyparse();
  return EXIT_SUCCESS;
}
