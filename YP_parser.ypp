
%{
#include <stdio.h>
#include <iostream>
#include <string>
#include <vector>

#include "src/type_table.hpp"
#include "src/symbol_table.hpp"

extern FILE* yyin;
extern char* yytext;
extern int yylineno;

type_table t_table;
char* name_class;
size_t count_fields;
std::string* fields;

symbol_table s_table("global");
int count_error;

extern bool method_master_started;
long long scopes_started;

extern int yylex();
void yyerror(const char * s);
%}

//------------------------------------------------
//------------------------------------------------

%union {
    char* token_name;
}

%type method_master
%token<token_name> method_type method_print
%token R_CLS A_PRV A_PUB A_FLD
%token OPERATOR_ASSIGN OPERATOR_RELTIN

%token<token_name> S_NME R_TYP 
%token<token_name> C_INT C_FLT C_CHR C_STR C_BOL

%token R_SEQ_IF R_SEQ_FOR R_SEQ_WHL

%start starting_symbol

%%
starting_symbol : global_declaration { if(0 == count_error) printf("the program was compiled correctly.\n"); } ;
scope_begin : '{' { scopes_started++; };
scope_end   : '}' { /* this case will never occur:
                        if(scopes_started <= 0) yyerror("ending an unstarted scope");*/ scopes_started--; };
method_master   : scope_begin statement_list;

//------------------------------------------------

/* class = type */
/* declaration, definition and call states for class
* class
* function
* variable
* object */

/*! class states */
cls_decl: R_CLS S_NME ';' { /* this case will never occur: 
                if(scopes_started) yyerror("classes can only be declared globally");*/ }
        | cls_defn
        ;
arr_fild: fct_defn { /*t_table[name_class].add_fct_field();*/ } arr_fild
        | var_decl { /*t_table[name_class].add_var_field();*/ } arr_fild
        | obj_decl { /*t_table[name_class].add_obj_field();*/ } arr_fild
        | A_PRV arr_fild
        | A_PUB arr_fild
        | scope_end // { t_table.add(name_class.c_str(), fields, count_fields); count_fields = 0; }
        ;
cls_defn: R_CLS S_NME scope_begin { name_class = $2; /*t_table.add(name_class);*/ } arr_fild /* store the type */ ;
/* cls_call is not needed for now */

/*! function states */
fct_decl: R_TYP S_NME fct_synp ';' // {table.add ($2, $1, nullptr);}
        | fct_defn
        ;
fct_synp: '(' arr_parm ')'
        | '('')'
arr_parm: R_TYP S_NME ',' arr_parm
        | R_TYP S_NME
        ;
fct_defn: R_TYP S_NME fct_synp scope_begin statement_list;
argument: S_NME | cst_call;
arr_argm: argument ',' arr_argm
        | argument
        ;
fct_call: S_NME '(' arr_argm ')' { /* provide return capacity */ } ;
        | S_NME '(' ')' { /* provide return capacity */ } ;

/*! variable states */
var_decl: R_TYP S_NME ';'{ /* initialize with defauld value */ /*table.add ($2, $1, nullptr);*/ }
        | var_defn
        ;
var_defn: R_TYP S_NME OPERATOR_ASSIGN S_NME ';' /* (1) */ ;
var_call: S_NME ;

/*! object states */
obj_decl: S_NME S_NME ';'
        | obj_defn
        ;
obj_defn: S_NME S_NME OPERATOR_ASSIGN scope_begin { /* search in the type table */ } scope_end ';' ;
fld_call: S_NME A_FLD S_NME { /* search type, search field */ } ;
obj_call: S_NME ;

/*! text constant states */
cst_call: C_INT
        | C_FLT
        | C_CHR
        | C_STR
        | C_BOL
        ;

/*! declaration parser */
global_declaration      : cls_decl global_declaration
	                | fct_decl global_declaration
	                | var_decl global_declaration
                        | obj_decl global_declaration
                        | method_master | ';' global_declaration
	                ;
local_declaration       : fct_decl local_declaration | fct_decl
                        | var_decl local_declaration | var_decl
                        | obj_decl local_declaration | obj_decl
                        ;

//------------------------------------------------

/*! statements */
statement_list  : statement_parse statement_list
                | scope_begin statement_list scope_end /* adds scopes for the fun of it */
                | scope_end /* halting condition */
                ;

/* statements types and parsing technique */
statement_parse : statement_easy
                | statement_bool
                | statement_assg
                | method_type ';'
                | method_print ';' { std::string s = $1 + 6; s[s.size() - 1] = '\0'; printf("%s", s.c_str()); }
                // | statement_cond
                // | local_declaration
                ;
call_parse      : fct_call
                | var_call
                | fld_call
                // | obj_call
                | cst_call
                ;

/* redundant statementes */
 statement_easy  : call_parse ';' | ';' ;

/* assignation statement */// here is needed a recursive approach
statement_assg  : S_NME OPERATOR_ASSIGN call_parse ';'
                | S_NME OPERATOR_ASSIGN method_type ';'
                | S_NME OPERATOR_ASSIGN method_print ';'
                ;

/* bool returning statements */
statement_bool  : S_NME OPERATOR_RELTIN S_NME ;

/* conditional statements */
condition_append: ';'
                | statement_parse
                | scope_begin statement_list scope_end
                | scope_begin scope_end
                ;
// statement_if    : R_SEQ_IF '(' statement_bool ')' condition_append;
// statement_for   : R_SEQ_FOR '(' /* declare */ ';' statement_bool ';' /* statement */ ')' condition_append;
// statement_whl   : R_SEQ_WHL '(' statement_bool ')' condition_append;
// statement_cond  : statement_if ;//| statement_for | statement_whl;

%%

//------------------------------------------------
//------------------------------------------------
// C++ functions:

void yyerror(const char * s){
    printf("error - line %d: %s.\n", yylineno, s);
}

int main(int argc, char** argv)
{
    if(argc != 2)
    {
        printf("error: wrong number of arguments.\n");
        return EXIT_FAILURE;
    }

    yyin = fopen(argv[1],"r");
    yyparse();
   
    return 0;
}