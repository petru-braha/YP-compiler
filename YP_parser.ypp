/* comments:
 * YP_parser.ypp - bottom-up parser, LARL(1) grammar
 * (c) authors - Braha Petru Bogdan - <petrubraha@gmail.com>
 *             - Meraru Ioan Lucian - <https://github.com/Zamdacmalfal>
 * run command example: ./YP exs/success/declaration/class/declaration.txt
 * run command example: ./YP exs/fail/declaration/class/field\ 0.txt
 
 *!* compilation should never throw exceptions *!*
 *!* all data is encoded as string *!*
 
 * states:
 ** declaration
 ** definition
 ** call
 * order of state presentation:
 ** class
 ** variable
 ** function
 ** object
 * statements

 * class == type
 * the number of started scopes == symbols.size(); 
 * exception: symbol table insertions won't provide error messages

 * how error checks are written: 
    for each terminal/non-terminal we perform checks
    we start with the first one and continue consecutively
 */

%{
#include <stdio.h>
#include <cstring>
#include <string>
#include <vector>
#include "YP_utility.hpp"

extern int yylex();
void yyerror(const char * s);

extern FILE* yyin;
extern char* yytext;
extern int yylineno;
extern bool master_started;
size_t count_error;

std::string cls_last_name;
function_data* f_data_global;
object_data* o_data_global;
function_data::it fctit_global;
object_data::it objit_global;

std::vector<symbol_table> symbols;
#define LAST_SCOPE symbols.size() - 1
%}

%left '&' '|'
%left "==" "!=" "<=" "<" ">=" ">"
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'

%right '='
%right '^'

%union {
  char* information;
  unsigned char character;

  bool bool_number;
  long long intg_number;
  double real_number;
}

%token<information> MASTER TYPEOF PRINTF
%token RSV_CLSS ACS_PRIV ACS_PUBL ACS_FILD

%token<information> SMT_NAME RSV_TYPE
%token<intg_number> LIT_INTG LIT_CHAR LIT_BOOL
%token<real_number> LIT_FLOT
%token<information> LIT_STRG
%type<information> LIT_CALL

%token<character> OPR_ASSIGN OPR0 OPR1 OPR2 OPR3 OPR4
%token<information> OPR_RELTON

%type<information> expression
%type<intg_number> expression_intg
%type<intg_number> term_intg
%type<intg_number> fact_intg
%type<intg_number> powr_intg

%type<real_number> expression_flot
%type<real_number> term_flot
%type<real_number> fact_flot
%type<real_number> powr_flot

%type<intg_number> expression_char
%type<intg_number> term_char
%type<intg_number> fact_char
%type<intg_number> powr_char

%type<information> expression_strg
%type<information> term_strg

%type<bool_number> expression_bool
%type<bool_number> term_bool

%start starting_symbol

/*!------------------------------------------------
/*!------------------------------------------------
/*! grammar */

%%
starting_symbol : { /* TODO add Type and Print */ 
                    symbols.emplace_back(); } 
                  global_declaration MASTER {
                    if(false == master_started)
                    {
                      yyerror("no master function found");
                      count_error++;
                    }

                    if(0 == count_error)
                      printf("the program was compiled correctly.\n");
                    else
                      printf("the program has %zu errors.\n", count_error);
                  };

/*!------------------------------------------------
/*! class states */

cls_decl: RSV_CLSS SMT_NAME ';' {
            if(size_t(-1) != scope_search($2))
              yyerror("identifier already defined");
            if(LAST_SCOPE)
              yyerror("classes can only be declared globally");
              free($2);
          }
        | cls_defn;

cls_defn: RSV_CLSS SMT_NAME '{' { // scope_begin => emplaces back
            bool is_error = false, error_flag = false;
            
            error_flag |= is_error =
              size_t(-1) != scope_search($2);
            if(is_error)
              yyerror("identifier already defined");
            
            error_flag |= is_error = 0 != LAST_SCOPE;
            if(is_error)
              yyerror("classes can only be declared globally");
            
            // success
            if(false == error_flag)
            {
              cls_last_name = $2;
              type_insert(cls_last_name, symbol_table($2));
            }

            free($2);
          }

          arr_fild { cls_last_name.clear(); };

          /*! 1 variable rules */
arr_fild: RSV_TYPE SMT_NAME ';' {
            bool is_error = false, error_flag = false;

            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");

            error_flag |= is_error =
              type_exists(cls_last_name)->get_data($2);
            if(is_error)
              yyerror("identifier already defined in class");
            
            // success
            if(false == error_flag)
            {
              variable_data v_data($1);
              type_exists(cls_last_name)->insert($2, &v_data);
            }
            
            free($1); free($2);
          } 
          
          arr_fild

        /*! 5 function rules */

        // constructors
        | SMT_NAME {
            bool is_error = false, error_flag = false;

            // it must be a type - the class type
            error_flag |= is_error =
              std::string($1) != cls_last_name;
            if(is_error)
              yyerror("constructor should be labeled as class");

            // success
            if(false == error_flag)
            {
              function_data f_data($1);
              type_exists(cls_last_name)->insert($1, &f_data);
              f_data_global = (function_data*)
                type_exists(cls_last_name)->get_data($1);
            }
          } 
          
          '(' arr_parm scope_begin statement_list {
            f_data_global = nullptr;
            free($1);
          } 
          
          arr_fild

        | RSV_TYPE SMT_NAME {
            bool is_error = false, error_flag = false;

            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");
            
            error_flag |= is_error =
              type_exists(cls_last_name)->get_data($2);
            if(is_error)
              yyerror("identifier already defined in class");

            // success
            if(false == error_flag)
            {
              function_data f_data($1);
              type_exists(cls_last_name)->insert($2, &f_data);
              f_data_global = (function_data*)
                type_exists(cls_last_name)->get_data($2);
            }
          } 
          
          '(' parametr arr_parm scope_begin statement_list {
              f_data_global = nullptr;
              free($1); free($2);
          } 
          
          arr_fild

        | RSV_TYPE SMT_NAME {
            bool is_error = false, error_flag = false;

            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");
            
            error_flag |= is_error =
              type_exists(cls_last_name)->get_data($2);
            if(is_error)
              yyerror("identifier already defined in class");

            // success
            if(false == error_flag)
            {
              function_data f_data($1);
              type_exists(cls_last_name)->insert($2, &f_data);
            }
          } 
          
          '('')' scope_begin statement_list {
              free($1); free($2);
          } 
          
          arr_fild
        
        | SMT_NAME SMT_NAME {
            bool is_error = false, error_flag = false;

            error_flag |= is_error = 
              nullptr == type_exists($1);
            if(is_error)
              yyerror("undefined type");
            
            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");
            
            error_flag |= is_error =
              type_exists(cls_last_name)->get_data($2);
            if(is_error)
              yyerror("identifier already defined in class");

            // success
            if(false == error_flag)
            {
              function_data f_data($1);
              type_exists(cls_last_name)->insert($2, &f_data);
              f_data_global = (function_data*)
                type_exists(cls_last_name)->get_data($2);
            }
          } 
          
          '(' parametr arr_parm scope_begin statement_list {
              f_data_global = nullptr;
              free($1); free($2); 
          } 
          
          arr_fild

        | SMT_NAME SMT_NAME {
            bool is_error = false, error_flag = false;

            error_flag |= is_error = 
              nullptr == type_exists($1);
            if(is_error)
              yyerror("undefined type");
            
            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");
            
            error_flag |= is_error =
              type_exists(cls_last_name)->get_data($2);
            if(is_error)
              yyerror("identifier already defined in class");

            // success
            if(false == error_flag)
            {
              function_data f_data($1);
              type_exists(cls_last_name)->insert($2, &f_data);
            }  
          } 
          
          '('')' scope_begin statement_list {
              free($1); free($2); 
          } 
          
          arr_fild

        /*! 1 object rules */
        | SMT_NAME SMT_NAME ';' {
            bool is_error = false, error_flag = false;
        
            error_flag |= is_error =
              nullptr == type_exists($1);
            if(is_error)
              yyerror("undefined type");
            
            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");
              
            error_flag |= is_error =
              type_exists(cls_last_name) &&
              type_exists(cls_last_name)->get_data($2);
            if(is_error)
              yyerror("identifier already defined in class");
            
            // success
            if(false == error_flag)
            {
              object_data o_data($1);
              type_exists(cls_last_name)->insert($2, &o_data);
            }

            free($1); free($2); 
          } 
          
          arr_fild
        
        /*! 2 access rules */
        | ACS_PRIV arr_fild /* TODO: semantics but much later */
        | ACS_PUBL arr_fild /* TODO: semantics but much later */
        | '}'
        ;
        
/*!------------------------------------------------
/*! 1 variable rule */

var_decl: RSV_TYPE SMT_NAME ';' {
            bool is_error = false, error_flag = false;
            
            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");
              
            error_flag |= is_error =
              size_t(-1) != scope_search($2);
            if(is_error)
              yyerror("identifier already defined");
            
            // success
            if(false == error_flag)
            {
              variable_data v_data($1);
              symbols[LAST_SCOPE].insert($2, &v_data);
            }

            free($1); free($2); 
          }
        ;

/*!------------------------------------------------
/*! function states */

fct_decl: RSV_TYPE SMT_NAME '(' parametr arr_parm ';' {
            size_t scope = scope_search($2);
            if(size_t(-1) != scope)
            {
              item_data* i_data = symbols.at(scope).get_data($2);
              if(i_data && ITEM_TYPE_FCT !=
                i_data->get_item_type())
                yyerror("identifier already defined");
            }
            free($1); free($2);
          }
        | RSV_TYPE SMT_NAME '('')' ';' {
            size_t scope = scope_search($2);
            if(size_t(-1) != scope)
            {
              item_data* i_data = symbols.at(scope).get_data($2);
              if(i_data && ITEM_TYPE_FCT !=
                i_data->get_item_type())
                yyerror("identifier already defined");
            }
            free($1); free($2);
          }

        | SMT_NAME SMT_NAME '(' parametr arr_parm ';' {
            if(nullptr == type_exists($1))
              yyerror("undefined type");
            free($1); free($2);
          }
        | SMT_NAME SMT_NAME '('')' ';' {
            if(nullptr == type_exists($1))
              yyerror("undefined type");
            free($1); free($2);
          }

        | fct_defn
        ;

fct_defn: RSV_TYPE SMT_NAME {
            bool is_error = false, error_flag = false;
  
            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");
            
            error_flag |= is_error =
              size_t(-1) != scope_search($2);
            if(is_error)
              yyerror("identifier already defined");

            if(false == error_flag)
            {
              function_data f_data($1);
              symbols[LAST_SCOPE].insert($2, &f_data);
              f_data_global = (function_data*)
                symbols.at(LAST_SCOPE).get_data($2);
            }} '(' parametr arr_parm scope_begin statement_list {
            f_data_global = nullptr;
            free($1); free($2);
          }
        | SMT_NAME SMT_NAME {
            bool is_error = false, error_flag = false;

            error_flag |= is_error =
              nullptr == type_exists($1);
            if(is_error)
              yyerror("undefined type");
            
            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");
            
            error_flag |= is_error =
              size_t(-1) != scope_search($2);
            if(is_error)
              yyerror("identifier already defined");
            
            if(false == error_flag)
            {
              function_data f_data($1);
              f_data_global = &f_data;
              symbols[LAST_SCOPE].insert($2, &f_data);
            }} '(' parametr arr_parm scope_begin statement_list {
            f_data_global = nullptr;
            free($1); free($2);
          }
        ;

arr_parm: parametr arr_parm;
parametr: ',' RSV_TYPE SMT_NAME {
            if(nullptr == f_data_global)
              yyerror("function parameter can't be created");
            else
            {
              variable_data v_data($2);
              f_data_global->
                parameter_insert($3, &v_data);
            }
            
            free($2); free($3); 
          }
        | ',' SMT_NAME SMT_NAME {
            bool is_error = false, error_flag = false;

            error_flag |= is_error =
              nullptr == f_data_global;
            if(is_error)
              yyerror("function parameter can't be created");
            
            error_flag |= is_error =
              nullptr == type_exists($2);
            if(is_error)
              yyerror("undefined type");
            
            if(false == error_flag)
            {
              object_data o_data($2);
              f_data_global->
                parameter_insert($3, &o_data);
            }
            
            free($2); free($3);
          }

        | ',' RSV_TYPE {
            if(nullptr == f_data_global)
              yyerror("function parameter can't be created");
            else
            {
              variable_data v_data($2);
              f_data_global->
                parameter_insert(&v_data);
            }
            
            free($2);
          }
        | ',' SMT_NAME {
            bool is_error = false, error_flag = false;

            error_flag |= is_error =
              nullptr == f_data_global;
            if(is_error)
              yyerror("function parameter can't be created");
            
            error_flag |= is_error =
              nullptr == type_exists($2);
            if(is_error)
              yyerror("undefined type");
            
            if(false == error_flag)
            {
              object_data o_data($2);
              f_data_global->
                parameter_insert(&o_data);
            }
            
            free($2);
          }

        | ')'
        ;

/*!------------------------------------------------
/*! 2 object rules */

obj_decl: SMT_NAME SMT_NAME ';' {
            bool is_error = false, error_flag = false;
            
            error_flag |= is_error =
              nullptr == type_exists($1);
            if(is_error)
              yyerror("undefined type");

            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");
            
            error_flag |= is_error =
              size_t(-1) != scope_search($2);
            if(is_error)
              yyerror("identifier already defined");
              
            // success
            if(false == error_flag)
            {
              object_data o_data($1);
              symbols[LAST_SCOPE].insert($2, &o_data);
            }

            free($1); free($2);
          }
        | obj_defn
        ;

obj_defn: SMT_NAME SMT_NAME OPR_ASSIGN SMT_NAME ';' {
            bool is_error = false, error_flag = false;
            
            error_flag |= is_error =
              nullptr == type_exists($1);
            if(is_error)
              yyerror("undefined type");
            
            error_flag |= is_error = is_type($2);
            if(is_error)
              yyerror("type treated as an identifier");

            error_flag |= is_error =
              size_t(-1) != scope_search($2);
            if(is_error)
              yyerror("identifier already defined");
            
            item_data* argument = nullptr;
            size_t scope = scope_search($4);
            if(size_t(-1) != scope)
              argument = symbols.at(scope).get_data($4);

            error_flag |= is_error = (nullptr == argument) ||
                (argument && std::string($2) == std::string($4));
            if(is_error)
              yyerror("undefined argument");

            // success
            if(false == error_flag)
            {
              object_data o_data($1, *(object_data*)argument);
              symbols[LAST_SCOPE].insert($2, &o_data);
            }
              
            free($1); free($2); free($4);
          }

/*! text constant states */
LIT_CALL: LIT_INTG { $$ = ($1); }
        | LIT_FLOT { $$ = ($1); }
        | LIT_CHAR { $$ = ($1); }
        | LIT_STRG { $$ = ($1); }
        | LIT_BOOL { $$ = ($1); }
        ;

/*!------------------------------------------------
/*!------------------------------------------------
/*! statements and expressions */

global_declaration: cls_decl global_declaration
	                | fct_decl global_declaration
	                | var_decl global_declaration
                  | obj_decl global_declaration
                  | ';' global_declaration
                  |
                  /*todo should allow expressions here too*/
	                ;

scope_begin : '{' { symbols.emplace_back(); };
scope_end   : '}' { symbols.pop_back(); };
method_master   : scope_begin statement_list;

local_declaration : var_decl
                  //| var_defn
                  | fct_decl
                  //| fct_defn
                  | obj_decl
                  //| obj_defn
                  ;

statement_list: statement_list local_declaration
              | scope_begin statement_list scope_end statement_list
              //| expression_parse statement_list
              | scope_end
              ;

/*! expression */
arr_argm        : ',' expression arr_argm
                | ')'
                ;
fct_call        : SMT_NAME '(' expression arr_argm
                | SMT_NAME '('')'
                ;

expression: expression_intg { $$ = strdup(std::to_string($1).c_str()); }
          | expression_flot { $$ = strdup(std::to_string($1).c_str()); }
          | expression_char { $$ = strdup(std::to_string($1).c_str()); }
          | expression_strg { $$ = strdup(std::to_string($1).c_str()); }
          | expression_bool { $$ = strdup(std::to_string($1).c_str()); }
          ;

/*! int */
expression_intg : term_intg OPR0 expression_intg {
                    if('+' == $2)
                      $$ = $1 + $3;
                    else
                      $$ = $1 - $3;
                  }
                | term_intg OPR0 '-' expression_intg {
                    if('+' == $2)
                      $$ = $1 + -1*$4;
                      else
                    $$ = $1 - -1*$4;
                  }

                | term_intg { $$ = $1; }
                ;
term_intg : term_intg OPR1 fact_intg {
              if('*' == $2)
                $$ = $1 * $3;
              else
                $$ = $1 / $3;
            }
          | term_intg OPR3 fact_intg { $$ = $1 % $3; }
          | fact_intg { $$ = $1; }
          ;
fact_intg : fact_intg OPR2 powr_intg { $$ = std::pow($1, $3); }
          | powr_intg { $$ = $1; }
          ;
powr_intg : '(' expression_intg ')' { $$ = $2; }
          | LIT_INTG { $$ = $1; }
          ;

/*! float */
expression_flot : term_flot OPR0 expression_flot {
                    if('+' == $2)
                      $$ = $1 + $3;
                    else
                      $$ = $1 - $3;
                  }
                | term_flot OPR0 '-' expression_flot {
                    if('+' == $2)
                      $$ = $1 + -1*$4;
                    else
                      $$ = $1 - -1*$4;
                  }
                | term_flot { $$ = $1; }
                ;
term_flot : term_flot OPR1 fact_flot {
              if('*' == $2)
                $$ = $1 * $3;
              else
                $$ = $1 / $3;
            }
          | fact_flot { $$ = $1; }
          ;
fact_flot : fact_flot OPR2 powr_flot { $$ = std::pow($1, $3); }
          | powr_flot { $$ = $1; }
          ;
powr_flot : '(' expression_flot ')' { $$ = $2; }
          | LIT_FLOT { $$ = $1; }
          ;

/*! char */
expression_char : term_char OPR0 expression_char {
                    if('+' == $2)
                      $$ = $1 + $3;
                    else
                      $$ = $1 - $3;
                  }
                | term_char OPR0 '-' expression_char {
                    if('+' == $2)
                      $$ = $1 + -1*$4;
                    else
                      $$ = $1 - -1*$4;
                  }
                | term_char { $$ = $1; }
                ;
term_char : term_char OPR1 fact_char {
              if('*' == $2)
                $$ = $1 * $3;
              else
                $$ = $1 / $3;
            }
          | term_char OPR3 fact_char { $$ = $1 % $3; }
          | fact_char { $$ = $1; }
          ;
fact_char : fact_char OPR2 powr_char { $$ = std::pow($1, $3); }
          | powr_char { $$ = $1; }
          ;
powr_char : '(' expression_char ')' { $$ = $2; }
          | LIT_CHAR { $$ = $1; }
          ;

/*! string */
expression_strg : term_strg OPR0 expression_strg {
                    if('+' == $2)
                    {
                      std::string text($1);
                      text += $3;
                      $$ = strdup(text.c_str());
                    }
                    else
                    {
                      size_t position = 0;
                      std::string text($1), token($3);
                      while(std::string::npos != 
                        (position = text.find(token, position)))
                        text.erase(position, token.length());
                      $$ = strdup(text.c_str());
                    }

                    free($1);
                    free($3);
                  }
                | term_strg { $$ = strdup($1); free($1); }
                ;
term_strg : '(' expression_strg ')' { $$ = strdup($2); free($2); }
          | LIT_STRG { $$ = strdup($1); free($1); }
          ;

/*! bool */
expression_bool : term_bool OPR4 expression_bool {
                    if('&' == $2)
                      $$ = $1 && $3;
                    else
                      $$ = $1 || $3;
                  }
                | term_bool OPR4 '!' expression_bool {
                   if('&' == $2)
                      $$ = $1 && $4;
                    else
                      $$ = $1 || $4;
                  }
                | term_bool { $$ = $1; }
                ;
term_bool : '(' expression_bool ')' { $$ = $2; }
          | LIT_BOOL { $$ = $1; }
          | expression_intg OPR_RELTON expression_intg {              
              if(0 == strcmp($2, "=="))
                $$ = $1 == $3;
              else if(0 == strcmp($2, "!="))
                $$ = $1 != $3;
              else if(0 == strcmp($2, "<="))
                $$ = $1 <= $3;
              else if(0 == strcmp($2, "<"))
                $$ = $1 < $3;
              else if(0 == strcmp($2, ">="))
                $$ = $1 >= $3;
              else if(0 == strcmp($2, ">"))
                $$ = $1 > $3;
            }
          | expression_flot OPR_RELTON expression_flot {
              if(0 == strcmp($2, "=="))
                $$ = $1 == $3;
              else if(0 == strcmp($2, "!="))
                $$ = $1 != $3;
              else if(0 == strcmp($2, "<="))
                $$ = $1 <= $3;
              else if(0 == strcmp($2, "<"))
                $$ = $1 < $3;
              else if(0 == strcmp($2, ">="))
                $$ = $1 >= $3;
              else if(0 == strcmp($2, ">"))
                $$ = $1 > $3;
            }
          | expression_char OPR_RELTON expression_char {
              if(0 == strcmp($2, "=="))
                $$ = $1 == $3;
              else if(0 == strcmp($2, "!="))
                $$ = $1 != $3;
              else if(0 == strcmp($2, "<="))
                $$ = $1 <= $3;
              else if(0 == strcmp($2, "<"))
                $$ = $1 < $3;
              else if(0 == strcmp($2, ">="))
                $$ = $1 >= $3;
              else if(0 == strcmp($2, ">"))
                $$ = $1 > $3;
            }
          | expression_strg OPR_RELTON expression_strg {
              if(0 == strcmp($2, "=="))
                $$ = $1 == $3;
              else if(0 == strcmp($2, "!="))
                $$ = $1 != $3;
              else if(0 == strcmp($2, "<="))
                $$ = $1 <= $3;
              else if(0 == strcmp($2, "<"))
                $$ = $1 < $3;
              else if(0 == strcmp($2, ">="))
                $$ = $1 >= $3;
              else if(0 == strcmp($2, ">"))
                $$ = $1 > $3;
            }
          ;

/*! assignation statement */
/* int a = (b = 5 + c); - recursive approach
statement_assg  : SMT_NAME OPR_ASSIGN call_parse ';'
                | SMT_NAME OPR_ASSIGN method_type ';'
                | SMT_NAME OPR_ASSIGN method_print ';'
                ;
*/

/*! conditional statements */
/*
condition_append: ';'
                | statement_parse
                | scope_begin statement_list scope_end
                | scope_begin scope_end
                ;
*/

// statement_if    : R_SEQ_IF '(' statement_bool ')' condition_append;
// statement_for   : R_SEQ_FOR '(' /* declare */ ';' statement_bool ';' /* statement */ ')' condition_append;
// statement_whl   : R_SEQ_WHL '(' statement_bool ')' condition_append;
// statement_cond  : statement_if ;//| statement_for | statement_whl;

%%

/*!------------------------------------------------
/*!------------------------------------------------
/*! C++ functions */

// does not stop the compilation
void yyerror(const char * s){
  count_error++;
  printf("error - line %d: %s.\n", yylineno, s);
  if(0 == strcmp(s, "syntax error"))
    printf("the program has %zu errors.\n", count_error);
}

int main(int argc, char** argv)
{
  if(argc != 2)
  {
    yyerror("wrong number of arguments");
    return EXIT_FAILURE;
  }

  FILE* ptr = fopen(argv[1], "r");
  if(nullptr == ptr)
  {
    yyerror("invalid file");
    return EXIT_FAILURE;
  }

  yyin = ptr;
  yyparse();
  return EXIT_SUCCESS;
}
