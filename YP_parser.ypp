/* comments:
 * YP_parser.ypp - bottom-up parser, LARL(1) grammar
 * (c) authors - Braha Petru Bogdan - <petrubraha@gmail.com>
 *             - Meraru Ioan Lucian - <https://github.com/Zamdacmalfal>
 * run command example: ./YP exs/success/declaration/class/declaration.txt
 * run command example: ./YP exs/fail/declaration/class/field\ 0.txt
 
 *!* compilation should never throw exceptions *!*
 *!* all data is encoded as string *!*
 
 * rules' summary
  * declarations
  ** class(type)
  ** variable
  ** function
  ** object
  * statements
  ** expression
  ** fct_call
  ** control
  ** assignment
 * order of function rules
  ** yes parameters - no  array
  ** yes parameters - yes array
  ** no  parameters - no  array
  ** no  parameters - yes array
 */

%{
  #include <stdio.h>
  #include <cstring>
  #include <cmath>
  #include <string>
  #include <vector>

  #include "src/class/primitive_data.hpp"
  #include "src/class/function_data.hpp"
  #include "src/class/object_data.hpp"
  #include "src/class/array_data.hpp"
  #include "src/class/class_data.hpp"

  #include "src/class/symbol_table.hpp"
  #include "src/class/type_table.hpp"

  #include "src/ast_expression.hpp"
  #include "src/ast_call.hpp"
  #include "src/ast_indexing.hpp"
  
  #include "src/ast_definition.hpp"
  #include "src/ast_action.hpp"
  #include "src/ast_scope.hpp"
  #include "src/ast_control.hpp"
  
  #include "src/implementation.hpp"

  extern int yylex();
  void yyerror(const char * s);

  extern FILE* yyin;
  extern char* yytext;
  extern int yylineno;
  size_t count_error;
  char global_access;

  std::vector<symbol_table> symbols;
  #define LAST_SCOPE symbols.size() - 1
  void initialize_compiler();
%}

%left '&' '|'
%left "==" "!=" "<=" "<" ">=" ">"
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'

%right '='
%right '^'

%code requires
{
  #include <string>
  #include <vector>
  #include <unordered_map>
  
  class item_data;

  struct field_data;
  class ast_statement;
  class ast_expression;
}
%union {
  char* information;
  char character;

  std::pair<std::string, field_data>* class_field;
  std::unordered_map<std::string, field_data>* class_content; 

  ast_statement* s_node;
  ast_expression* e_node;
  std::vector<ast_statement*>* subast;
  std::vector<ast_expression*>* subexp;
}

%token SCOPE_BEGIN SCOPE_END
%token TYPEOF PRINTF MASTER

%token RSV_CLSS ACS_PRIV ACS_PUBL ACS_FILD
%token<character> OPR0 OPR1 OPR2 OPR3 OPRU
%token<information> LITERAL

%token ACT_BREK ACT_CONT ACT_RTRN
%token SEQ_IFIF SEQ_ELSE SEQ_WHLE SEQ_FOOR

%token<information> RSV_TYPE RSV_ARRY SMT_NAME DEF_ARRY

%type<class_field> cls_fild
%type<class_content> arr_fild

%type<s_node> var_decl var_defn
%type<s_node> fct_decl fct_defn
%type<s_node> obj_decl obj_defn
%type<s_node> cls_decl cls_defn

%type<s_node> scope
%type<subast> arr_stat
%type<s_node> stat ctrl decl
%type<e_node> expr term fact unit asgn

%type<subexp> arr_argm

%start starting_symbol

%%

/*! declaration */

/* 1c rules */
cls_decl: RSV_CLSS SMT_NAME ';'{
            /*if(size_t(-1) != scope_search($2))
              yyerror("identifier already defined");*/
            free($2);
          }
        ;

/* 2c rules */
cls_defn: RSV_CLSS SMT_NAME SCOPE_BEGIN arr_fild SCOPE_END {
            $$ = new ast_typecall($2,
              new class_data($4));
          }
        | RSV_CLSS SMT_NAME SCOPE_BEGIN SCOPE_END {
            $$ = new ast_typecall($2,
              new class_data(
                new std::unordered_map<std::string, field_data>()));
          }
        ;

arr_fild: arr_fild cls_fild { 
            $1->insert(*$2);
            $$ = $1;
          }
        | cls_fild {
            $$ = new std::unordered_map<std::string, field_data>();
            $$->insert(*$1);
          }
        ;

cls_fild: var_decl
        | var_defn
        | fct_defn
        | obj_decl
        | obj_defn
        | ACS_PRIV
        | ACS_PUBL
        ;

/* 4v rules */
var_decl: RSV_TYPE SMT_NAME { $$ = new ast_declaration($1, $2); }
        | RSV_ARRY SMT_NAME { $$ = new ast_declaration($1, $2); }
        ;
var_defn: RSV_TYPE SMT_NAME OPR3 expr { $$ = new ast_definition($1, $2, $4); }
        | RSV_ARRY SMT_NAME OPR3 expr { $$ = new ast_definition($1, $2, $4); }
        ;

/* 8f rules */
fct_decl: RSV_TYPE SMT_NAME '(' arr_parm parametr ')'
        | RSV_ARRY SMT_NAME '(' arr_parm parametr ')'
        | RSV_TYPE SMT_NAME '(' ')'
        | RSV_ARRY SMT_NAME '(' ')'
        | SMT_NAME SMT_NAME '(' arr_parm parametr ')'
        | DEF_ARRY SMT_NAME '(' arr_parm parametr ')'
        | SMT_NAME SMT_NAME '(' ')'
        | DEF_ARRY SMT_NAME '(' ')'
        ;
/* 8f rules */
fct_defn: RSV_TYPE SMT_NAME '(' arr_parm parametr ')' scope
        | RSV_ARRY SMT_NAME '(' arr_parm parametr ')' scope
        | RSV_TYPE SMT_NAME '(' ')' scope
        | RSV_ARRY SMT_NAME '(' ')' scope
        | SMT_NAME SMT_NAME '(' arr_parm parametr ')' scope
        | DEF_ARRY SMT_NAME '(' arr_parm parametr ')' scope
        | SMT_NAME SMT_NAME '(' ')' scope
        | DEF_ARRY SMT_NAME '(' ')' scope
        ;
arr_parm: arr_parm parametr ','
        | /* epsilon */ {}
        ;
parametr: RSV_TYPE SMT_NAME
        | RSV_ARRY SMT_NAME
        | SMT_NAME SMT_NAME
        | DEF_ARRY SMT_NAME
        ;

/* 4o rules */
obj_decl: SMT_NAME SMT_NAME {}
        | DEF_ARRY SMT_NAME {}
        ;
obj_defn: SMT_NAME SMT_NAME OPR3 '{' attribte obj_vals
        | DEF_ARRY SMT_NAME OPR3 '{' attribte obj_vals
        ;
obj_vals: ',' attribte obj_vals
        | '}'
        ;
attribte: expr
        ;

/*! statements */

starting_symbol : { initialize_compiler(); } glb_decl {
                    if(0 == count_error)
                      printf("the program was compiled correctly.\n");
                    else
                      printf("the program has %zu errors.\n", count_error);
                  }
                //| test
                ;

/*test: SMT_NAME { printf("f"); }
    | SMT_NAME OPR3 test { printf("t"); }
    ;*/

glb_decl: glb_decl decl
        | MASTER scope {
            symbols.emplace_back();
            $2->evaluate();
            delete $2;
          }
        ;

scope : SCOPE_BEGIN arr_stat SCOPE_END { $$ = new ast_scope($2); }
      | SCOPE_BEGIN SCOPE_END {
            $$ = new ast_scope(new std::vector<ast_statement*>);
        }
      ;

arr_stat: arr_stat stat { $1->emplace_back($2); $$ = $1; }
        | stat {
            $$ = new std::vector<ast_statement*>;
            $$->emplace_back($1);
          }
        ;

stat: asgn ';' { $$ = $1; }
    | ACT_BREK ';' { $$ = new ast_action(ACT_BREAK); }
    | ACT_CONT ';' { $$ = new ast_action(ACT_CONTINUE); }
    | ACT_RTRN expr ';' { $$ = new ast_return($2); }
    | decl { $$ = $1; }
    | ctrl { $$ = $1; }
    | scope { $$ = $1; }
    ;

decl: var_decl ';' { $$ = $1; }
    | var_defn ';' { $$ = $1; }
    | fct_decl ';' { $$ = $1; }
    | fct_defn ';' { $$ = $1; }
    | obj_decl ';' { $$ = $1; }
    | obj_defn ';' { $$ = $1; }
    | cls_decl ';' { $$ = $1; }
    | cls_defn ';' { $$ = $1; }
    ;

asgn: expr { $$ = $1; }
    | SMT_NAME OPR3 asgn {
        ast_symbolcall* id = new ast_symbolcall($1);
        $$ = new ast_assign(id, $3);
      }
    ;

expr: expr OPR0 term { $$ = new ast_operator($1, $2, $3); }
    | term { $$ = $1; }
    ;
term: fact OPR1 term { $$ = new ast_operator($1, $2, $3); }
    | fact { $$ = $1; }
    ;
fact: fact OPR2 unit { $$ = new ast_operator($1, $2, $3); }
    | unit { $$ = $1; }
    ;
unit: '(' asgn ')' { $$ = $2; }
    | OPRU expr ')' { 
        $$ = new ast_operator(
          new ast_constant((char*)"0"), $1, $2);
      }

    // variable
    | LITERAL { $$ = new ast_constant($1); }
    | SMT_NAME { $$ = new ast_symbolcall($1); }
    
    // function
    | TYPEOF '(' expr ')' { $$ = new ast_vanillacall($3, VNL_TYPEOF); }
    | PRINTF '(' expr ')' { $$ = new ast_vanillacall($3, VNL_PRINTF); }
    | SMT_NAME '('')' { 
        $$ = new ast_methodcall(
          new ast_symbolcall($1),
          new std::vector<ast_expression*>()); 
      }
    | SMT_NAME '(' arr_argm expr ')' { 
        $3->emplace_back($4);
        $$ = new ast_methodcall(
          new ast_symbolcall($1),
          $3);
      }

    // object
    /*
    | SMT_NAME ACS_FILD SMT_NAME { 
        $$ = new ast_fielding(
          new ast_symbolcall($1),
          $2);
      }
    | SMT_NAME ACS_FILD SMT_NAME '('')' { 
        $$ = new ast_fieldcall($1, $2,
          new std::vector<ast_expression*>());
      }
    | SMT_NAME ACS_FILD SMT_NAME '(' arr_argm expr ')'{
        $5->emplace_back($6);
        $$ = new ast_fieldcall($1, $3, $5);
      }
    */

    // array
    | SMT_NAME '[' expr ']' { 
        $$ = new ast_indexing(
          new ast_symbolcall($1),
          $3);
      }
    ;

arr_argm: arr_argm expr ',' { $1->emplace_back($2); $$ = $1; }
        | /*epsilon*/ { $$ = new std::vector<ast_expression*>(); }
        ;

ctrl: SEQ_IFIF '(' expr ')' 
        SCOPE_BEGIN arr_stat SCOPE_END {
          $$ = new ast_ifelse($3, 
            new ast_scope_control($6), 
            new ast_scope_control(
              new std::vector<ast_statement*>())); 
        }
    | SEQ_IFIF '(' expr ')'
        SCOPE_BEGIN arr_stat SCOPE_END
        SEQ_ELSE SCOPE_BEGIN arr_stat SCOPE_END {
          $$ = new ast_ifelse($3, 
            new ast_scope_control($6), 
            new ast_scope_control($10));
        }
    | SEQ_WHLE '(' expr ')'
        SCOPE_BEGIN arr_stat SCOPE_END {
          $$ = new ast_while($3, 
            new ast_scope_control($6));
        }
    | SEQ_FOOR '(' stat ';' expr ';' stat ')' 
        SCOPE_BEGIN arr_stat SCOPE_END {
          $$ = new ast_for($3, $5, $7, 
            new ast_scope_control($10));
        }
    ;
%%

/*!------------------------------------------------
/*!------------------------------------------------
/*! C++ functions */

void yyerror(const char * s)
{
  count_error++;
  printf("error - line %d: %s.\n", yylineno, s);
  if(0 == strcmp(s, "syntax error"))
    printf("the program has %zu errors.\n", count_error);
}

int main(int argc, char** argv)
{
  if(argc != 2)
  {
    yyerror("wrong number of arguments");
    return EXIT_FAILURE;
  }

  FILE* ptr = fopen(argv[1], "r");
  if(nullptr == ptr)
  {
    yyerror("invalid file");
    return EXIT_FAILURE;
  }

  yyin = ptr;
  yyparse();
  return EXIT_SUCCESS;
}
