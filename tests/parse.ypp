%{
#include <stdio.h>
#include <cstring>
#include <cmath>
#include <string>
#include <vector>
#include "util.hpp"

extern int yylex();
void yyerror(const char * s);

extern FILE* yyin;
extern char* yytext;
extern int yylineno;
extern bool method_master_started;
size_t count_error;
std::vector<symbol_table> symbols;
#define LAST_SCOPE symbols.size() - 1
%}

%left '&' '|'
%left "==" "!=" "<=" "<" ">=" ">"
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'

%right '='
%right '^'

%union {
  char* information;
  unsigned char character;
    
  bool bool_number;
  long long intg_number;
  double real_number;
}

%token SCOPE_BEGIN SCOPE_END
%token MASTER TYPEOF PRINTF

%token RSV_CLSS ACS_PRIV ACS_PUBL ACS_FILD

%token<information> SMT_NAME RSV_TYPE RSV_ARRY DEF_ARRY
%token<intg_number> LIT_INTG LIT_CHAR LIT_BOOL
%token<real_number> LIT_FLOT
%token<information> LIT_STRG
%type<information> LIT_CALL

%token<character> OPR_ASSIGN OPRU OPR0 OPR1 OPR2
%token<information> OPR_RELTON

%type<information> expression
%type<information> term
%type<information> fact
%type<information> powr

%token ACT_BREK ACT_CONT ACT_RTRN
%token SEQ_IFIF SEQ_ELSE SEQ_WHLE SEQ_FOOR

%start starting_symbol

%%
/*! declaration */

starting_symbol : global_declaration;
global_declaration: MASTER
                    SCOPE_BEGIN { symbols.emplace_back(); }
                    statement_list
                  | cls_decl global_declaration
                  | cls_defn global_declaration
                  | var_decl global_declaration
                  | var_defn global_declaration
                  | fct_decl global_declaration
                  | fct_defn global_declaration
                  | obj_decl global_declaration
                  | obj_defn global_declaration
                  ;

cls_decl: RSV_CLSS SMT_NAME ';';

cls_defn: RSV_CLSS SMT_NAME '{' cls_fild arr_fild
        | RSV_CLSS SMT_NAME '{' '}'
        ;

arr_fild: cls_fild arr_fild
        | '}'
        ;

cls_fild: RSV_TYPE SMT_NAME ';'
        | RSV_ARRY SMT_NAME ';'
        | RSV_TYPE SMT_NAME OPR_ASSIGN expression ';'
        | RSV_ARRY SMT_NAME OPR_ASSIGN expression ';'
        
        | RSV_TYPE SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | RSV_ARRY SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | RSV_TYPE SMT_NAME '('')'
          SCOPE_BEGIN
          statement_list ';'
        | RSV_ARRY SMT_NAME '('')'
          SCOPE_BEGIN
          statement_list ';'
          
        | SMT_NAME SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | DEF_ARRY SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | SMT_NAME SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';'
        | DEF_ARRY SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';'

        | SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';'
        | SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
  
        | SMT_NAME SMT_NAME ';'
        | DEF_ARRY SMT_NAME ';'
        | SMT_NAME SMT_NAME OPR_ASSIGN '{' attribte obj_vals
        | DEF_ARRY SMT_NAME OPR_ASSIGN '{' attribte obj_vals
        | ACS_PRIV
        | ACS_PUBL
        ;

var_decl: RSV_TYPE SMT_NAME ';'
        | RSV_ARRY SMT_NAME ';'
        ;
var_defn: RSV_TYPE SMT_NAME OPR_ASSIGN expression ';'
        | RSV_ARRY SMT_NAME OPR_ASSIGN expression ';'
        ;

fct_decl: RSV_TYPE SMT_NAME '(' parametr arr_parm ';'
        | RSV_ARRY SMT_NAME '(' parametr arr_parm ';'
        | RSV_TYPE SMT_NAME '(' ')' ';'
        | RSV_ARRY SMT_NAME '(' ')' ';'
        | SMT_NAME SMT_NAME '(' parametr arr_parm ';'
        | DEF_ARRY SMT_NAME '(' parametr arr_parm ';'
        | SMT_NAME SMT_NAME '(' ')' ';'
        | DEF_ARRY SMT_NAME '(' ')' ';'
        ;
fct_defn: RSV_TYPE SMT_NAME '(' parametr arr_parm 
          SCOPE_BEGIN
          statement_list ';'
        | RSV_ARRY SMT_NAME '(' parametr arr_parm 
          SCOPE_BEGIN
          statement_list ';'
        | RSV_TYPE SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';'
        | RSV_ARRY SMT_NAME '(' ')'
          SCOPE_BEGIN
          statement_list ';'
        | SMT_NAME SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | DEF_ARRY SMT_NAME '(' parametr arr_parm
          SCOPE_BEGIN
          statement_list ';'
        | SMT_NAME SMT_NAME '(' ')'
          SCOPE_BEGIN
        | DEF_ARRY SMT_NAME '(' ')'
          SCOPE_BEGIN
        ;
arr_parm: parametr arr_parm
        | ')'
        ;
parametr: ',' RSV_TYPE SMT_NAME
        | ',' RSV_ARRY SMT_NAME
        | ',' SMT_NAME SMT_NAME
        | ',' DEF_ARRY SMT_NAME
        ;

obj_decl: SMT_NAME SMT_NAME ';'
        | DEF_ARRY SMT_NAME ';'
        ;
obj_defn: SMT_NAME SMT_NAME OPR_ASSIGN '{' attribte obj_vals
        | DEF_ARRY SMT_NAME OPR_ASSIGN '{' attribte obj_vals
        ;
obj_vals: ',' attribte obj_vals
        | '}'
        ;
attribte: expression
        ;

LIT_CALL: LIT_INTG { $$ = nullptr; }
        | LIT_FLOT { $$ = nullptr; }
        | LIT_CHAR { $$ = nullptr; }
        | LIT_STRG { $$ = nullptr; }
        | LIT_BOOL { $$ = nullptr; }
        ;

/*! statement */
statement_list: SCOPE_END { symbols.pop_back(); }
              | local_declaration statement_list
              | expression ';' statement_list
              | ACT_BREK
              | ACT_CONT
              | ACT_RTRN
              | control
              | assignment ';'
              ;

local_declaration : var_decl
                  | var_defn
                  | fct_decl
                  | fct_defn
                  | obj_decl
                  | obj_defn
                  ;

expression: term OPR0 expression { $$ = nullptr; }
          | term OPR0 OPRU expression { $$ = nullptr; }
          | term OPR_RELTON expression {              
              if(0 == strcmp($2, "=="))
                $$ = 0;
              else if(0 == strcmp($2, "!="))
                $$ = 0;
              else if(0 == strcmp($2, "<="))
                $$ = 0;
              else if(0 == strcmp($2, "<"))
                $$ = 0;
              else if(0 == strcmp($2, ">="))
                $$ = 0;
              else if(0 == strcmp($2, ">"))
                $$ = 0;
            }
          | term { $$ = nullptr; }
          ;
term: term OPR1 fact { $$ = nullptr; }
    | fact { $$ = $1; }
    ;
fact: fact OPR2 powr { $$ = nullptr; }
    | powr { $$ = $1; }
    ;
powr: '(' expression ')' { $$ = $2; }
    | LIT_CALL { $$ = $1; }
    | SMT_NAME { $$ = 0; }
    | SMT_NAME ACS_FILD SMT_NAME { $$ = 0; }
    | SMT_NAME '[' LIT_INTG ']' { $$ = 0; }
    | SMT_NAME '[' SMT_NAME ']' { $$ = 0; }
    | PRINTF '(' expression ')' { $$ = 0; printf("%s", $3); fflush(stdout); }
    | TYPEOF '(' expression ')' {
        std::string s = type_of($3);
        $$ = strdup(s.c_str());
      }
    | fct_call {$$ = nullptr; }
    ;

fct_call: SMT_NAME '(' expression arr_argm
        | SMT_NAME '('')'
        ;
arr_argm: ',' expression arr_argm
        | ')'
        ;

control : SEQ_IFIF '(' expression ')' '{' statement_list '}'
        | SEQ_IFIF '(' expression ')' '{' statement_list '}' SEQ_ELSE '{' statement_list '}'
        | SEQ_WHLE '(' expression ')' '{' statement_list '}'
        | SEQ_FOOR '(' expression ';' expression ';' expression ')' '{' statement_list '}'

assignment: SMT_NAME OPR_ASSIGN assig_term
          ;
assig_term: expression
          | assignment
          ;
%%

/*!------------------------------------------------
/*!------------------------------------------------
/*! C++ functions */

void yyerror(const char * s){
  count_error++;
  printf("error - line %d: %s.\n", yylineno, s);
  if(0 == strcmp(s, "syntax error"))
    printf("the program has %zu errors.\n", count_error);
}

int main(int argc, char** argv)
{
  if(argc != 2)
  {
    yyerror("wrong number of arguments");
    return EXIT_FAILURE;
  }

  FILE* ptr = fopen(argv[1], "r");
  if(nullptr == ptr)
  {
    yyerror("invalid file");
    return EXIT_FAILURE;
  }

  yyin = ptr;
  yyparse();
  return EXIT_SUCCESS;
}
