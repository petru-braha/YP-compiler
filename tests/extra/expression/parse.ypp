%{
#include <stdio.h>
#include <cstring>
#include <cmath>
#include <string>
#include <vector>
#include "util.hpp"

extern int yylex();
void yyerror(const char * s);

extern FILE* yyin;
extern char* yytext;
extern int yylineno;
extern bool method_master_started;
size_t count_error;
std::vector<symbol_table> symbols;
#define LAST_SCOPE symbols.size() - 1
%}
/*
%left '&' '|'
%left "==" "!=" "<=" "<" ">=" ">"
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'

%right '='
%right '^'
*/

%union {
    char* information;
    unsigned char character;
    
    bool bool_number;
    long long intg_number;
    double real_number;
}

%token<intg_number> LIT_INTG
%token<real_number> LIT_FLOT
%token<information> LIT_CHAR LIT_STRG
%token<bool_number> LIT_BOOL
%type<information> LIT_CALL

// %token OPR_ASSIGN
%token<character> OPRU OPR0 OPR1 OPR2
%token<information> OPR_RELTON

%type<information> expression
%type<information> term
%type<information> fact
%type<information> powr

%start starting_symbol

%%

starting_symbol : expression { printf("result: %s\n", $1); if(std::string($1) == std::string("69")) printf("nice\n"); } ;

expression: term OPR0 expression {
              std::string type_first(type_of($1));
              std::string type_secnd(type_of($3));
              if(type_first != type_secnd)
                yyerror("bad");

              std::string s;
              if('+' == $2 || '-' == $2)
              {
                if(std::string("bool") == type_first)
                  yyerror("bad");

                if(std::string("int") == type_first)
                {
                  long long var0 = atoll($1);
                  long long var1 = atoll($3);
                  long long result = '+' == $2 ? var0 + var1 : var0 - var1;
                  s = std::to_string(result);
                }
                else if(std::string("float") == type_first)
                {
                  double var0 = atof($1);
                  double var1 = atof($3);
                  double result = '+' == $2 ? var0 + var1 : var0 - var1;
                  s = std::to_string(result);
                }
                else if(std::string("char") == type_first)
                {
                  long long result = '+' == $2 ? $1[1] + $3[1] : $1[1] - $3[1];
                  s = std::to_string(result);
                }
                else if(std::string("string") == type_first)
                {
                  if('+' == $2)
                  {
                    s = std::string($1);
                    s += $3;
                  }
                  else
                  {
                    size_t position = 0;
                    s = std::string($1);
                    std::string token($3);
                    while(std::string::npos != 
                      (position = s.find(token, position)))
                      s.erase(position, token.length());
                  }
                }                
              }
              else
              {
                if(std::string("bool") != type_first)
                  yyerror("bad");

                if('&' == $2)
                {
                  if(std::string("false") == std::string($1) ||
                  std::string("false") == std::string($3))
                    s = std::string("false");
                  else
                    s = std::string("true");
                }
                else
                {
                  if(std::string("true") == std::string($1) ||
                  std::string("true") == std::string($3))
                    s = std::string("true");
                  else
                    s = std::string("false");
                }
              }
              $$ = strdup(s.c_str());
          }
          | term OPR_RELTON expression {
              std::string type_first(type_of($1));
              std::string type_secnd(type_of($3));
              if(type_first != type_secnd)
                yyerror("bad");
              
              std::string value0($1), value1($3);
              if(0 == strcmp($2, "=="))
                $$ = value0 == value1 ? strdup("true") : strdup("false");
              else if(0 == strcmp($2, "!="))
                $$ = value0 == value1 ? strdup("false") : strdup("true");
              else if(0 == strcmp($2, "<="))
                $$ = value0 <= value1 ? strdup("true") : strdup("false");
              else if(0 == strcmp($2, "<"))
                $$ = value0 < value1 ? strdup("true") : strdup("false");
              else if(0 == strcmp($2, ">="))
                $$ = value0 >= value1 ? strdup("true") : strdup("false");
              else if(0 == strcmp($2, ">"))
                $$ = value0 > value1 ? strdup("true") : strdup("false");
              
              free($1);
              free($3);
            }
          | term { $$ = strdup($1); free($1); }
          ;
term: term OPR1 fact {
        std::string type_first(type_of($1));
        std::string type_secnd(type_of($3));
        if(type_first != type_secnd)
          yyerror("bad");
        
        if('*' == $2 || '/' == $2)
        {
          if(std::string("string") == type_first ||
            std::string("bool") == type_first)
            yyerror("bad");
          
          if(std::string("int") == type_first)
          {
            long long var0 = atoll($1);
            long long var1 = atoll($3);
            long long result = '*' == $2 ? var0 * var1 : var0 / var1;
            std::string s = std::to_string(result);
            $$ = strdup(s.c_str());
          }
          else if(std::string("float") == type_first)
          {
            double var0 = atof($1);
            double var1 = atof($3);
            double result = '*' == $2 ? var0 * var1 : var0 / var1;
            std::string s = std::to_string(result);
            $$ = strdup(s.c_str());
          }
          else if(std::string("char") == type_first)
          {
            long long result = '*' == $2 ? $1[1] * $3[1] : $1[1] / $3[1];
            std::string s = std::to_string(result);
            $$ = strdup(s.c_str()); 
          }
        }
        else if('%' == $2)
        {
          if(std::string("string") == type_first ||
            std::string("bool") == type_first ||
            std::string("float") == type_first)
            yyerror("bad");
          
          if(std::string("int") == type_first)
          {
            long long var0 = atoll($1);
            long long var1 = atoll($3);
            long long result = var0 % var1;
            std::string s = std::to_string(result);
            $$ = strdup(s.c_str());
          }
          else if(std::string("char") == type_first)
          {
            long long result = $1[1] % $3[1];
            std::string s = std::to_string(result);
            $$ = strdup(s.c_str());
          }
        }

        free($1);
        free($3);
      }
    | fact { $$ = strdup($1); free($1); }
    ;
fact: fact OPR2 powr {
        std::string type_first(type_of($1));
        if(std::string("string") == type_first ||
          std::string("bool") == type_first ||
          std::string("char") == type_first)
          yyerror("bad");

        std::string type_secnd(type_of($3));
        if(type_first != type_secnd)
          yyerror("bad");
        
        if(std::string("int") == type_first)
        {
          long long var0 = atoll($1);
          long long var1 = atoll($3);
          long long result = std::pow(var0, var1);
          std::string s = std::to_string(result);
          $$ = strdup(s.c_str());
        }
        else if(std::string("float") == type_first)
        {
          double var0 = atof($1);
          double var1 = atof($3);
          double result = std::pow(var0, var1);
          std::string s = std::to_string(result);
          $$ = strdup(s.c_str());
        }
          
        free($1);
        free($3);
      }
    | powr { $$ = strdup($1); free($1); }
    ;
powr: '(' expression ')' { $$ = strdup($2); free($2); }
    | LIT_CALL { $$ = strdup($1); free($1); }
    | OPRU '(' expression ')' {
        std::string type(type_of($3));

        std::string s;
        if('-' == $1)
        {
          if(std::string("bool") == type ||
            std::string("string") == type)
            yyerror("bad");
            
          if(std::string("int") == type)
          {
            long long result = 0 - atoll($3);
            s = std::to_string(result);
          }
          else if(std::string("float") == type)
          {
            double result = 0.0 - atof($3);
            s = std::to_string(result);
          }
          else if(std::string("char") == type)
          {
            long long result = 0 - $3[1];
            s = std::to_string(result);
          }
        }
        else
        {
          if(std::string("bool") != type)
            yyerror("bad");
          std::string("true") == std::string($3) ? s = "false" : s = "true";
        }

        $$ = strdup(s.c_str());
        free($3);
      }
    | OPRU LIT_CALL {
        std::string type(type_of($2));

        std::string s;
        if('-' == $1)
        {
          if(std::string("bool") == type ||
            std::string("string") == type)
            yyerror("bad");
            
          if(std::string("int") == type)
          {
            long long result = 0 - atoll($2);
            s = std::to_string(result);
          }
          else if(std::string("float") == type)
          {
            double result = 0.0 - atof($2);
            s = std::to_string(result);
          }
          else if(std::string("char") == type)
          {
            long long result = 0 - $2[1];
            s = std::to_string(result);
          }
        }
        else
        {
          if(std::string("bool") != type)
            yyerror("bad");
          std::string("true") == std::string($2) ? s = "false" : s = "true";
        }

        $$ = strdup(s.c_str());
        free($2);
      }
    ;
  
LIT_CALL: LIT_INTG { std::string s = std::to_string($1); $$ = strdup(s.c_str()); }
        | LIT_FLOT { std::string s = std::to_string($1); $$ = strdup(s.c_str()); }
        | LIT_CHAR { $$ = strdup($1); free($1); }
        | LIT_STRG { $$ = strdup($1); free($1); }
        | LIT_BOOL { $$ = false == $1 ? strdup("false") : strdup("true"); }
        ;
%%

/*!------------------------------------------------
/*!------------------------------------------------
/*! C++ functions */

void yyerror(const char * s){
  count_error++;
  printf("error - line %d: %s.\n", yylineno, s);
}

int main(int argc, char** argv)
{
  if(argc != 2)
  {
    yyerror("wrong number of arguments");
    return EXIT_FAILURE;
  }

  FILE* ptr = fopen(argv[1], "r");
  if(nullptr == ptr)
  {
    yyerror("invalid file");
    return EXIT_FAILURE;
  }

  yyin = ptr;
  yyparse();
  return EXIT_SUCCESS;
}
