%{
#include <stdio.h>
#include <cstring>
#include <cmath>
#include <string>
#include <vector>
#include "util.hpp"
#include "arithmetic.hpp"

extern int yylex();
void yyerror(const char * s);

extern FILE* yyin;
extern char* yytext;
extern int yylineno;
extern bool method_master_started;
size_t count_error;
std::vector<symbol_table> symbols;
#define LAST_SCOPE symbols.size() - 1
%}
/*
%left '&' '|'
%left "==" "!=" "<=" "<" ">=" ">"
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'

%right '='
%right '^'
*/

%union {
    char* information;
    unsigned char character;
    
    bool bool_number;
    long long intg_number;
    double real_number;
}

%token<intg_number> LIT_INTG
%token<real_number> LIT_FLOT
%token<information> LIT_CHAR LIT_STRG
%token<bool_number> LIT_BOOL
%type<information> LIT_CALL

// %token OPR_ASSIGN
%token<character> OPRU OPR0 OPR1 OPR2
%token<information> OPR_RELTON

%type<information> expression
%type<information> term
%type<information> fact
%type<information> powr

%start starting_symbol

%%

starting_symbol : expression { printf("result: %s\n", $1); if(std::string($1) == std::string("69")) printf("nice\n"); } ;

expression: expression OPR0 term {
              switch($2)
              {
                case '+':
                  $$ = add_vals($1, $3);
                  break;
                case '-':
                  $$ = sub_vals($1, $3);
                  break;
                case '&':
                  $$ = and_vals($1, $3);
                  break;
                case '|':
                  $$ = or__vals($1, $3);
                  break;
                default:
                  $$ = nullptr;
                  break;
              }

            free($1);
            free($3);
          }
          | expression OPR_RELTON term {
              $$ = cmp_vals($1, $2, $3);
              free($1);
              free($3);
            }
          | term { $$ = strdup($1); free($1); }
          ;
term: fact OPR1 term {
        switch($2)
        {
          case '*':
            $$ = mul_vals($1, $3);
            break;
          case '/':
            $$ = div_vals($1, $3);
            break;
          case '%':
            $$ = mod_vals($1, $3);
            break;
          default:
            $$ = nullptr;
            break;
        }
        
        free($1);
        free($3);
      }
    | fact { $$ = strdup($1); free($1); }
    ;
fact: fact OPR2 powr {
        $$ = pow_vals($1, $3);
          
        free($1);
        free($3);
      }
    | powr { $$ = strdup($1); free($1); }
    ;
powr: '(' expression ')' { $$ = strdup($2); free($2); }
    | LIT_CALL { $$ = strdup($1); free($1); }
    | OPRU expression ')' {

        if('!' == $1)
          $$ = negation($2);
        else
          $$ = chg_sign($2);

        free($2);
      }
    ;
  
LIT_CALL: LIT_INTG { std::string s = std::to_string($1); $$ = strdup(s.c_str()); }
        | LIT_FLOT { std::string s = std::to_string($1); $$ = strdup(s.c_str()); }
        | LIT_CHAR { $$ = strdup($1); free($1); }
        | LIT_STRG { $$ = strdup($1); free($1); }
        | LIT_BOOL { $$ = false == $1 ? strdup("false") : strdup("true"); }
        ;
%%

/*!------------------------------------------------
/*!------------------------------------------------
/*! C++ functions */

void yyerror(const char * s){
  count_error++;
  printf("error - line %d: %s.\n", yylineno, s);
}

int main(int argc, char** argv)
{
  if(argc != 2)
  {
    yyerror("wrong number of arguments");
    return EXIT_FAILURE;
  }

  FILE* ptr = fopen(argv[1], "r");
  if(nullptr == ptr)
  {
    yyerror("invalid file");
    return EXIT_FAILURE;
  }

  yyin = ptr;
  yyparse();
  return EXIT_SUCCESS;
}
