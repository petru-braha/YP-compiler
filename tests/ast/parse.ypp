%{
  #include <stdio.h>
  #include <cstring>
  #include <cmath>
  #include <string>
  #include <vector>
  #include "util.hpp"
  #include "arithmetic.hpp"
  #include "ast_base.hpp"

  int yylex();
  void yyerror(const char * s);

  extern FILE* yyin;
  extern char* yytext;
  extern int yylineno;
  size_t count_error;
%}

%left '&' '|'
%left "==" "!=" "<=" "<" ">=" ">"
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'

%right '='
%right '^'

%code requires
{
  class ast_expression;
  class ast_variable;
  class ast_operator;
}
%union {
  char* information;
  char character;
  ast_expression* node;
}

%token<information> LITERAL
%token<character> OPR0 OPR1 OPR2 OPR3 OPRU

%type<node> expr
%type<node> term
%type<node> fact
%type<node> powr
%type<node> unit

%start starting_symbol

%%

starting_symbol : 'a'
                | expr {
                    char* evaluation = $1->evaluate();
                    printf("result: %s\n", evaluation);
                    free(evaluation);
                    delete $1;
                  }
                ;

expr: expr OPR0 term { $$ = new ast_operator($1, $2, $3); }
    | term { $$ = $1; }
    ;
term: fact OPR1 term { $$ = new ast_operator($1, $2, $3); }
    | fact { $$ = $1; }
    ;
fact: fact OPR2 powr { $$ = new ast_operator($1, $2, $3); }
    | powr { $$ = $1; }
    ;
powr: powr OPR3 unit { $$ = new ast_operator($1, $2, $3); }
    | unit { $$ = $1; }
unit: '(' expr ')' { $$ = $2; }
    | LITERAL {
        $$ = new ast_variable($1); 
        free($1);
      }
    | OPRU expr ')' { $$ = new ast_operator(nullptr, $1, $2); }
    ;
%%

/*!------------------------------------------------
/*!------------------------------------------------
/*! C++ functions */

void yyerror(const char * s){
  count_error++;
  printf("error - line %d: %s.\n", yylineno, s);
}

int main(int argc, char** argv)
{
  if(argc != 2)
  {
    yyerror("wrong number of arguments");
    return EXIT_FAILURE;
  }

  FILE* ptr = fopen(argv[1], "r");
  if(nullptr == ptr)
  {
    yyerror("invalid file");
    return EXIT_FAILURE;
  }

  yyin = ptr;
  yyparse();
  return EXIT_SUCCESS;
}
